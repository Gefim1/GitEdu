# Интрукции для работы с Markdown

# Общее:

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться
в компьютерных играх (в Git эквивалент игрового сохранения — коммит).
000Любой файл в папке существующего репозитория может находиться или не
находиться под версионным контролем (отслеживаемые и неотслеживаемые).
Неотслеживаемые файлы можно в любой момент сделать отслеживаемыми и
наоборот.
Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые,
изменённые, готовые к коммиту. Сразу после клонирования репозитория все
файлы — отслеживаемые неизменённые.
После редактирования отслеживаемого файла он становится изменённым.
Изменения файла (или нескольких) можно индексировать (подготовить к
коммиту) и закоммитить. После коммита такие файлы становятся
отслеживаемыми неизменёнными.
Проверить состояние репозитория можно командой git status. Она покажет
ветку, изменённые файлы (если есть) с пометкой «modified», неотслеживаемые
файлы в списке «Untracked files».

## Выделение текста

Чтобы выделить текст курсивом, необходимо обрамить его звёздочками(*). Например, *вот так*

Язык разметки Markdown поддерживает 2 стиля обозначения заголовков:
подчеркивание и выделение символом («#»). Выделение заголовков с помощью
подчеркивания производится знаками равенства («=») в случае, если заголовок
первого уровня, и дефисами («-») в случае, если заголовок второго уровня.
Количество знаков подчеркивания не ограничивается. При выделении
заголовков с помощью символа («#») используется от одного до шести данных
символов, которые устанавливаются в начале строки (перед заголовком). В
данном случае количество символов соответствует уровню заголовка. Кроме
того, заголовок возможно снабдить закрывающимися символами («#»), хотя это
и не является обязательным. Количество закрывающихся символов не обязано
соответствовать количеству начальных символов. Уровень заголовка
определяется по количеству начальных символов.
Заголовки первого и второго уровней, выполненные с помощью подчеркивания,
выглядят следующим образом:
Заголовок первого уровня
========================
Заголовок второго уровня
-------------------------
Заголовки первого, третьего и шестого уровней, выполненные с помощью
символа («#»), выглядят следующим образом:
# Заголовок первого уровня
### Заголовок третьего уровня
###### Заголовок шестого уровня
Приведенные выше заголовки, выполненные с помощью символа («#»)
тождественны следующим:
# Заголовок первого уровня #
### Заголовок третьего уровня ###
###### Заголовок шестого уровня ######
## Списки

Markdown поддерживает упорядоченные (нумерованные) и неупорядоченные
(ненумерованные) списки. Для формирования неупорядоченный списков
используются такие маркеры, как звездочки, плюсы и дефисы. Все
перечисленные маркеры могут использоваться взаимозаменяемо. Для
формирования упорядоченных списков в качестве маркеров используются
числа с точкой. Важной особенностью в данном случае является то, что сами
номера, с помощью которых формируется список, не важны, так как они не
оказывают влияния на выходной HTML код. Как бы ни нумеровал пользователь
список, на выходе он в любом случае будет иметь упорядоченный список,
начинающийся с единицы (1, 2, 3…). Эту особенность стоит учитывать в том
случае, когда необходимо использовать порядковые номера элементов в
списке, чтобы они соответствовали номерам, получающимся в HTML.
Упорядоченные списки всегда следует начинать с единицы. Маркеры списков
обычно начинаются с начала строки, однако они могут быть сдвинуты, но не
более чем на 3 пробела. За маркером должен следовать пробел, либо символ
табуляции. При необходимости в список можно вставить цитату. В этом случае
обозначения цитирования ( «>» ) нужно писать с отступом. Упорядоченные
списки выглядят следующим образом:
1. Проводник
2. Полупроводник
3. Диэлектрик
Неупорядоченные списки выглядят следующим образом:
* Проводник
* Полупроводник
* Диэлектрик
Или
- Проводник
- Полупроводник
- Диэлектрик
Или
+ Проводник
+ Полупроводник
+ Диэлектрик
На выходе всех трех перечисленных вариантов имеется один и тот же результат.
В результате на экран выводится следующее:
1. Проводник
2. Полупроводник
3. Диэлектрик
и
Проводник
Полупроводник
Диэлектрик
Цитата, вставленная в список, выглядит следующим образом:
1. Элемент списка с цитатой:
> Это цитата
> внутри элемента списка.
2. Второй элемент списка

## Ссылки

Markdown поддерживает два стиля оформления ссылок:
Гиперссылка, с немедленным указанием адреса (внутритекстовая);
Гиперссылка, подобная сноске.
Подразумевается, что помимо URL-адреса существует еще текст ссылки. Он
заключается в квадратные скобки. Для создания внутритекстовой гиперссылки
необходимо использовать круглые скобки сразу после закрывающей
квадратной. Внутри них необходимо поместить URL-адрес. В них же возможно
расположить название, заключенное в кавычки, которое будет отображаться
при наведении, но этот пункт не является обязательным.
[пример](https://music.yandex.ru/radio)
В результате на экран выводится следующее: пример При ссылке на локальную
директорию возможно использование относительного пути (от текущей
страницы, сайта и т.п.)
При создании сносной гиперссылки вместо целевого адреса используется
вторая пара квадратных скобок, внутри которых помещается метка,
идентификатор ссылки (id).
[пример][id]: (https://music.yandex.ru/radio)
Также, можно использовать пробел, чтобы отделять 2 пары квадратных скобок:
[пример] [id]:
В этом случае возможно определить идентификатор в любом месте документа:
[id]: http://example.com/ "Необязательная подсказка
## Работа с изображениями

В Markdown существует 2 способа вставки изображений в документ:
a. С помощью непосредственного указания URL-адреса изображения. Синтаксис
данной команды выглядит следующим образом:

![Альтернативный текст](/путь/к/изображению.jpg)
или
![Альтернативный текст](/путь/к/изображению.jpg "Подсказка")

Иными словами, он состоит из следующих элементов:
восклицательный знак;
квадратные скобки, в которых указывается альтернативный изображению
текст (он станет содержимым атрибута в элементе img);
круглые скобки, содержащие URL-адрес или относительный путь
изображения, а также (необязательно) всплывающую подсказку,
заключённуе в двойные или одиночные кавычки.
b. С помощью метки-идентификатора. Синтаксис данной команды записывается
следующим образом:
![Альтернативный текст][id]
где «id» — имя определённой метки изображения. Метки изображений
определяются при помощи синтаксиса, совершенно идентичного меткам
гиперссылок:
[id]: путь/к/изображению "Необязательная подсказка"
Важной особенностью является то, что Markdown не позволяет задать размеры
изображения (ширину, высоту).


пример: 

## Цитаты

Для обозначения цитат в языке Markdown используется знак «больше» («>»). Его
можно вставлять как перед каждой строкой цитаты, так и только перед первой
строкой параграфа. Также синтаксис Markdown позволяет создавать вложенные
цитаты (цитаты внутри цитат). Для их разметки используются дополнительные
уровни знаков цитирования («>»). Цитаты в Markdown могут содержать
всевозможные элементы разметки. Цитаты в языке Markdown выглядят
следующим образом:
>Это пример цитаты,
>в которой перед каждой строкой
>ставится угловая скобка.
>Это пример цитаты,
в которой угловая скобка
ставится только перед началом нового параграфа.
>Второй параграф.
Вложение цитаты в цитату выглядит следующим образом:
> Первый уровень цитирования
>> Второй уровень цитирования
>>> Третий уровень цитирования
>
>Первый уровень цитирования
## Дополнительные элементы

Может употребляться в Markdown перед специальными символами для того,
чтобы они воспринимались в их буквальном (а не служебном) значении. Полный
список данных символов приводится ниже:
«\» - слеш;
«`» - обратный апостроф;
«*» - звездочка;
«_» - символ подчеркивания;
«{}» - фигурные скобки;
«[]» - квадратные скобки;
«()» - круглые скобки;
«#» - символ решетки;
«+» - плюс;
«-» - минус (дефис);
«.» – точка;
«!» - восклицательный знак.

##Таблицы

В чистом Маркдауне нет синтаксиса для таблиц, а в GFM есть.

First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell

Для красоты можно и по бокам линии нарисовать:

| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |

Можно управлять выравниванием столбцов при помощи двоеточия.

| Left-Aligned  | Center Aligned  | Right Aligned |
|:------------- |:---------------:| -------------:|
| col 3 is      | some wordy text |     **$1600** |
| col 2 is      | centered        |         $12   |
| zebra stripes | are neat        |        ~~$1~~ |

Внутри таблиц можно использовать ссылки, наклонный, жирный или зачеркнутый текст.

Для всего остального есть обычный HTML.

# Консольные команды

## Создать новый репозиторий

git init # создать новый проект в текущей папке
git init folder-name # создать новый проект в указанной папке
## Клонирование репозитория

git clone git@github.com:nicothin/web-design.git # клонировать удаленный
репозиторий в одноименную папку
git clone git@github.com:nicothin/web-design.git foldername # клонировать
удаленный репозиторий в папку «foldername»
git add . # добавить к отслеживанию все новые файлы из текущей папки и её
подпапок, индексировать отслеживаемые файлы
git add -i # запуск оболочки интерактивного индексирования для добавления в
индекс только выбранных файлов
git add -p # поочередный просмотр файлов с показом изменений и задаваемым
вопросом об отслеживании/индексировании (удобно для добавления в коммит
только каких-то конкретных файлов)

## Убирание файла, папки из отслеживания

git rm --cached readme.txt # удалить файл из отслеживаемых (файл останется на
месте)
git rm --cached -r folder # удалить папку из отслеживаемых (папка останется на
месте)

## Отмена индексации

git reset HEAD # убрать из индекса все индексированные файлы
git reset HEAD text. txt # убрать из индекса указанный файл

## Просмотр изменений

git diff # посмотреть непроиндексированные изменения (если есть, иначе
ничего не выведет)
git diff --staged # посмотреть проиндексированные изменения (если есть, иначе
ничего не выведет)

## Отмена изменений

git checkout -- text.txt # ОПАСНО: отменить все изменения, внесенные в
отслеживаемый файл со времени предыдущего коммита (файл не добавлен в
индекс)

## Коммиты

git commit -m "Name of commit" # закоммитить отслеживаемые
индексированные файлы (указано название коммита)
git commit -a -m "Name of commit" # закоммитить отслеживаемые
индексированные файлы (указано название коммита, не требует git add, не
добавит в коммит неотслеживаемые файлы)
git commit # закоммитить отслеживаемые индексированные файлы (откроется
редактор для введения названия коммита)
git commit --amend # изменить последний коммит (Insert — режим ввода, : —
командный режим; в командном режиме: :wq — сохранить и выйти)
git commit --amend -m "Новое название" # переименовать последний коммит
(только если ещё не был отправлен в удалённый репозиторий)

## Отмена коммитов

git revert HEAD --no-edit # создать новый коммит, отменяющий изменения
последнего коммита без запуска редактора сообщения
git revert b9533bb --no-edit # создать новый коммит, отменяющий изменения
указанного (b9533bb) коммита без запуска редактора сообщения (указаны
первые 7 символов хеша коммита)
git reset --hard 75e2d51 # вернуть репозиторий в состояние коммита с
указанным хешем ОПАСНО! пропадет вся работа, сделанная после этого
коммита

## Временно переключиться на другой коммит

git checkout b9533bb # временно переключиться на коммит с указанным хешем
git checkout master # вернуться к последнему коммиту в указанной ветке

## Переключиться на другой коммит и продолжить работу с него

git rm text.txt # удалить из отслеживаемых неиндексированный файл (файл
будет удален из папки)
git rm -f text.txt # удалить из отслеживаемых индексированный файл (файл
будет удален из папки)
git rm -r log/ # удалить из отслеживаемых всё содержимое папки log/ (папка
будет удалена)
git rm ind* # удалить из отслеживаемых все файлы с именем, начинающимся на
«ind» в текущей папке (файлы будут удалены из папки)
git rm --cached readme.txt # удалить из отслеживаемых индексированный файл
(файл останется на месте)

## История изменений

git log -p index.html # показать историю изменений файла index.html (выход из
длинного лога: Q)
git log -p -5 index.html # показать историю изменений файла index.html
(последние 5 коммитов, выход из длинного лога: Q)
git log -2 # показать последние 2 коммита
git log -2 --stat # показать последние 2 коммита и статистику внесенных ими
git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с
форматированием выводимых данных
git log --graph -10 # показать последние 10 коммитов с ASCII-представлением
ветвления
git log --since=2.weeks # показать коммиты за последние 2 недели
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short # мой формат
вывода, висящий на алиасе оболочки
git log master..branch_99 # показать коммиты из ветки branch_99, которые не
влиты в master
git log branch_99..master # показать коммиты из ветки master, которые не влиты
в branch_99
git show 60d6582 # показать изменения из коммита с указанным хешем
git show HEAD^ # показать данные о предыдущем коммите

## Работа с удалёнными репозиториями

Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

Удаленный репозиторий может находиться на вашем локальном компьютере.
Вполне возможно, что удалённый репозиторий будет находиться на том же компьютере, на котором работаете вы. Слово «удалённый» не означает, что репозиторий обязательно должен быть где-то в сети или Интернет, а значит только — где-то ещё. Работа с таким удалённым репозиторием подразумевает выполнение стандартных операций отправки и получения, как и с любым другим удалённым репозиторием.

## Просмотр удалённых репозиториев

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:

$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:

$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:

$ cd grit
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записи и в них можно отправлять свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.

Обратите внимание на разнообразие протоколов, используемых при указании адреса удалённого репозитория; подробнее мы рассмотрим протоколы в разделе Установка Git на сервер главы 4.

Добавление удалённых репозиториев
В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду git remote add <shortname> <url>:

$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду git fetch pb:

$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -> pb/master
 * [new branch]      ticgit     -> pb/ticgit
Ветка master из репозитория Пола сейчас доступна вам под именем pb/master. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола. Более подробно работа с ветками рассмотрена в главе Ветвление в Git.

Получение изменений из удалённого репозитория — Fetch и Pull
Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

$ git fetch [remote-name]
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, git fetch origin извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки (см. следующий раздел и главу Ветвление в Git чтобы получить больше информации), то вы можете использовать команду git pull чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

Начиная с версии 2.27, команда git pull выдаёт предупреждение, если настройка pull.rebase не установлена. Git будет выводить это предупреждение каждый раз пока настройка не будет установлена.

Если хотите использовать поведение Git по умолчанию (простое смещение вперёд если возможно — иначе создание коммита слияния): git config --global pull.rebase "false"

Если хотите использовать перебазирование при получении изменений: git config --global pull.rebase "true"0

## Отправка изменений в удаленный репозиторий (Push)

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: git push <remote-name> <branch-name>. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

$ git push origin master
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.

## Просмотр удаленного репозитория

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду git remote show <remote>. Выполнив эту команду с некоторым именем, например, origin, вы получите следующий результат:

$ git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните git pull, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

Это был пример для простой ситуации и вы наверняка встречались с чем-то подобным. Однако, если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от git remote show:0,,
## Удаление и переименование удалённых репозиториев

Для переименования удалённого репозитория можно выполнить git remote rename. Например, если вы хотите переименовать pb в paul, вы можете это сделать при помощи git remote rename:

$ git remote rename pb paul
$ git remote
origin
paul
Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как pb/master, теперь стало paul/master.

Если по какой-то причине вы хотите удалить удаленный репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать git remote rm:

$ git remote remove paul
$ git remote
origin
При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.
